#if !defined(ZDO_COORDINATOR) && !defined(RTR_NWK)
/**************************************************************************************************
  Filename:       SampleApp.c
  Revised:        $Date: 2009-03-18 15:56:27 -0700 (Wed, 18 Mar 2009) $
  Revision:       $Revision: 19453 $

  Description:    Sample Application (no Profile).


  Copyright 2007 Texas Instruments Incorporated. All rights reserved.

  IMPORTANT: Your use of this Software is limited to those specific rights
  granted under the terms of a software license agreement between the user
  who downloaded the software, his/her employer (which must be your employer)
  and Texas Instruments Incorporated (the "License").  You may not use this
  Software unless you agree to abide by the terms of the License. The License
  limits your use, and you acknowledge, that the Software may not be modified,
  copied or distributed unless embedded on a Texas Instruments microcontroller
  or used solely and exclusively in conjunction with a Texas Instruments radio
  frequency transceiver, which is integrated into your product.  Other than for
  the foregoing purpose, you may not use, reproduce, copy, prepare derivative
  works of, modify, distribute, perform, display or sell this Software and/or
  its documentation for any purpose.

  YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
  PROVIDED AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
  INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
  NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
  TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
  NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
  LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
  OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
  OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.

  Should you have any questions regarding your right to use this Software,
  contact Texas Instruments Incorporated at www.TI.com.
**************************************************************************************************/

/*********************************************************************
  This application isn't intended to do anything useful, it is
  intended to be a simple example of an application's structure.

  This application sends it's messages either as broadcast or
  broadcast filtered group messages.  The other (more normal)
  message addressing is unicast.  Most of the other sample
  applications are written to support the unicast message model.

  Key control:
    SW1:  Sends a flash command to all devices in Group 1.
    SW2:  Adds/Removes (toggles) this device in and out
          of Group 1.  This will enable and disable the
          reception of the flash command.
*********************************************************************/

/*********************************************************************
 * INCLUDES
 */
#include "OSAL.h"
#include "ZGlobals.h"
#include "AF.h"
#include "aps_groups.h"

#include "MT.h"
#include "MT_UART.h"
#include "SampleDevice.h"
#include "SampleAppHw.h"
#include <string.h>
#include "OnBoard.h"

/* HAL */
#include "hal_led.h"

#include "Sensor.h"

/*********************************************************************
 * MACROS
 */

/*********************************************************************
 * CONSTANTS
 */

/*********************************************************************
 * TYPEDEFS
 */

/*********************************************************************
 * GLOBAL VARIABLES
 */

// This list should be filled with Application specific Cluster IDs.
const cId_t SampleApp_ClusterList[SAMPLEAPP_MAX_CLUSTERS] =
{
  SAMPLEAPP_PERIODIC_CLUSTERID,
  SAMPLEAPP_FLASH_CLUSTERID
};

const SimpleDescriptionFormat_t SampleApp_SimpleDesc =
{
  SAMPLEAPP_ENDPOINT,              //  int Endpoint;
  SAMPLEAPP_PROFID,                //  uint16 AppProfId[2];
  SAMPLEAPP_DEVICEID,              //  uint16 AppDeviceId[2];
  SAMPLEAPP_DEVICE_VERSION,        //  int   AppDevVer:4;
  SAMPLEAPP_FLAGS,                 //  int   AppFlags:4;
  SAMPLEAPP_MAX_CLUSTERS,          //  uint8  AppNumInClusters;
  (cId_t *)SampleApp_ClusterList,  //  uint8 *pAppInClusterList;
  SAMPLEAPP_MAX_CLUSTERS,          //  uint8  AppNumInClusters;
  (cId_t *)SampleApp_ClusterList   //  uint8 *pAppInClusterList;
};

void testFunc_NwkStateChanged(const struct ep_info_t *ep, devStates_t curState);
void testFunc_NwkStateChanged(const struct ep_info_t *ep, devStates_t curState)
{
}
void testFunc_inComeData(const struct ep_info_t *ep, afMSGCommandFormat_t *msg);
void testFunc_inComeData(const struct ep_info_t *ep, afMSGCommandFormat_t *msg)
{
    //msg->Data[], msg->DataLength, msg->TransSeqNumber
    HalLedBlink( HAL_LED_2, 1, 50, 250 );
}
void testFunc_TimeOut(const struct ep_info_t *ep);
void testFunc_TimeOut(const struct ep_info_t *ep)
{
    // send sensor data to coordinator
    //    SampleApp_SendPeriodicMessage(task_id);
    SendData(ep->task_id, "Hello", 0x0000, SAMPLEAPP_ENDPOINT, 5);
}

struct ep_info_t funcList[] = {
    {
        testFunc_NwkStateChanged,
        testFunc_inComeData,
        testFunc_TimeOut,
        { 1, 0, 3 },
    },
};

#define FUNC_NUM        (sizeof(funcList) / sizeof(funcList[0]))

#include "hal_drivers.h"
#if defined ( ZIGBEE_FRAGMENTATION )
  #include "aps_frag.h"
#endif

const pTaskEventHandlerFn tasksArr[] = {
  macEventLoop,
  nwk_event_loop,
  Hal_ProcessEvent,
#if defined( MT_TASK )
  MT_ProcessEvent,
#endif
  APS_event_loop,
#if defined ( ZIGBEE_FRAGMENTATION )
  APSF_ProcessEvent,
#endif
  ZDApp_event_loop,
#if defined ( ZIGBEE_FREQ_AGILITY ) || defined ( ZIGBEE_PANID_CONFLICT )
  ZDNwkMgr_event_loop,
#endif
  controlEpProcess,
  functionEpProcess,
};
struct ep_info_t controlEndPointInfo;
uint8 controlTaskId, functionTaskId;
const uint8 tasksCnt = sizeof(tasksArr)/sizeof(tasksArr[0]);

/*********************************************************************
 * LOCAL FUNCTIONS
 */
uint8 SendData(uint8 srcEP, uint8 *buf, uint16 addr, uint8 dsrEP, uint8 Leng);

static struct topo_info_t {
  uint8 type;
  uint8 IEEE[8];
  uint16 PAddr;
} topoInfoBuffer;
static union {
  uint8 data[2 + FUNC_NUM * sizeof(struct func_info_t)];
  struct {
    uint8 type;
    uint8 num;
    struct func_info_t funcList[1];
  } field;
} funcListBuffer;
void taskInitProcess(void)
{
    int i;
    // 构造功能列表
    funcListBuffer.field.type = 0x01;
    funcListBuffer.field.num = FUNC_NUM;
    for(i = 1; i < FUNC_NUM; i++)
    {
        osal_memcpy(&funcListBuffer.field.funcList[i], &funcList[i].function, sizeof(struct func_info_t));
    }

    controlTaskId = tasksCnt - 2;
    functionTaskId = tasksCnt - 1;
    createEndPoint(&controlEndPointInfo, &controlTaskId, 0xF0);
    for(i = 0; i < FUNC_NUM; i++)
    {
        createEndPoint(&funcList[i], &functionTaskId, i + 1);
    }
}

void createEndPoint(struct ep_info_t *epInfo, uint8 *task_id, uint8 ep)
{
  // Fill out the endpoint description.
  epInfo->task_id = *task_id;
  epInfo->timerTick = epInfo->function.cycle;

  epInfo->SampleApp_epDesc.endPoint = ep;
  epInfo->SampleApp_epDesc.task_id = task_id;
  
  osal_memcpy(&epInfo->SampleApp_SimpleDesc, &SampleApp_SimpleDesc, sizeof(SampleApp_SimpleDesc));
  epInfo->SampleApp_SimpleDesc.EndPoint = ep;
  
  epInfo->SampleApp_epDesc.simpleDesc
            = (SimpleDescriptionFormat_t *)&epInfo->SampleApp_SimpleDesc;
  
  epInfo->SampleApp_epDesc.latencyReq = noLatencyReqs;

  // Register the endpoint description with the AF
  afRegister(&epInfo->SampleApp_epDesc);
}

uint16 controlEpProcess(uint8 task_id, uint16 events)
{
  afIncomingMSGPacket_t *MSGpkt;

  if ( events & SYS_EVENT_MSG )
  {
    MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive(task_id);
    while ( MSGpkt )
    {
      switch ( MSGpkt->hdr.event )
      {
        // Received when a messages is received (OTA) for this endpoint
        case AF_INCOMING_MSG_CMD:
          {
            // TODO: QueryProfile or QueryTopo
              switch ( MSGpkt->clusterId )
              {
                case SAMPLEAPP_PERIODIC_CLUSTERID:
                  switch(MSGpkt->cmd.Data[0])
                  {
                  case 0x01:
                    // CtrlQueryProfile
                    // TODO: 应当获取到数据包的来源地址来当做发送数据的目标
                    SendData(task_id, funcListBuffer.data, 0x0000, SAMPLEAPP_ENDPOINT, sizeof(funcListBuffer.data));
                  case 0x02:
                    // CtrlQueryTopo
                    // TODO: 应当获取到数据包的来源地址来当做发送数据的目标
                    SendData(task_id, (unsigned char *)&topoInfoBuffer, 0x0000, SAMPLEAPP_ENDPOINT, sizeof(topoInfoBuffer)); //节点向协调器发送采集数据
                    break;
                  }
                  HalLedBlink( HAL_LED_2, 1, 50, 250 );
                  break;
              }
          }
          break;
          // Received whenever the device changes state in the network
        case ZDO_STATE_CHANGE:
          // TODO: 确认这个消息是否会被派发到此任务
          {
              devStates_t SampleApp_NwkState = (devStates_t)(MSGpkt->hdr.status);
              if ( (SampleApp_NwkState == DEV_ZB_COORD)
                  || (SampleApp_NwkState == DEV_ROUTER)
                  || (SampleApp_NwkState == DEV_END_DEVICE) )
              {
                topoInfoBuffer.type = 0x02;
                memcpy(topoInfoBuffer.IEEE, NLME_GetExtAddr(), 8);
                topoInfoBuffer.PAddr = NLME_GetCoordShortAddr();
                
                HalLedBlink( HAL_LED_2, 4, 50, 250 );
              }
              else
              {
                // Device is no longer in the network
                // TODO:
              }
          }
          break;

        default:
          break;
      }
      // Release the memory
      osal_msg_deallocate( (uint8 *)MSGpkt );
      // Next - if one is available
      MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( task_id );
    }
    // return unprocessed events
    return (events ^ SYS_EVENT_MSG);
  }
  // Discard unknown events
  return 0;
}

uint16 functionEpProcess(uint8 task_id, uint16 events)
{
    afIncomingMSGPacket_t *MSGpkt;
    if ( events & SYS_EVENT_MSG )
    {
        MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( task_id );
        while ( MSGpkt )
        {
            switch ( MSGpkt->hdr.event )
            {
              // 接收到数据包
            case AF_INCOMING_MSG_CMD:
                {
                    switch ( MSGpkt->clusterId )
                    {
                    case SAMPLEAPP_PERIODIC_CLUSTERID:
                        //MSGpkt->cmd.Data[]
                        HalLedBlink( HAL_LED_2, 1, 50, 250 );
                        break;
                    }
                }
                break;
            
            // 普通的传感器需要这段代码
            // Received whenever the device changes state in the network
            case ZDO_STATE_CHANGE:
            // TODO: 确认这个消息是否会被派发到此任务
                {
                    devStates_t SampleApp_NwkState = (devStates_t)(MSGpkt->hdr.status);
                    if ( (SampleApp_NwkState == DEV_ZB_COORD)
                    || (SampleApp_NwkState == DEV_ROUTER)
                    || (SampleApp_NwkState == DEV_END_DEVICE) )
                    {
                        osal_start_timerEx( task_id,
                        SAMPLEAPP_SEND_PERIODIC_MSG_EVT,
                        SAMPLEAPP_SEND_PERIODIC_MSG_TIMEOUT );
                    }
                    else
                    {
                        // Device is no longer in the network
                    }
                }
                break;
            default:
                break;
            }
            
            // Release the memory
            osal_msg_deallocate( (uint8 *)MSGpkt );
            
            // Next - if one is available
            MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( task_id );
        }
        
        // return unprocessed events
        return (events ^ SYS_EVENT_MSG);
    }

    // 普通传感器编写下面的代码
    // Send a message out - This event is generated by a timer
    //  (setup in SampleApp_Init()).
    if ( events & SAMPLEAPP_SEND_PERIODIC_MSG_EVT )
    {
        // send sensor data to coordinator
        //    SampleApp_SendPeriodicMessage(task_id);
        SendData(task_id, "Hello", 0x0000, SAMPLEAPP_ENDPOINT, 5);
        
        // Setup to send message again in normal period (+ a little jitter)
        osal_start_timerEx( task_id, SAMPLEAPP_SEND_PERIODIC_MSG_EVT,
            SAMPLEAPP_SEND_PERIODIC_MSG_TIMEOUT );

        // return unprocessed events
        return (events ^ SAMPLEAPP_SEND_PERIODIC_MSG_EVT);
    }
    
    // Discard unknown events
    return 0;
}

//**********************************************************************
//**以短地址方式发送数据
//buf ::发送的数据
//addr::目的地址
//Leng::数据长度
//********************************************************************
uint8 SendData(uint8 srcEP, uint8 *buf, uint16 addr, uint8 dstEP, uint8 Leng)
{
  static uint8 transID = 0;
	afAddrType_t SendDataAddr;
        struct ep_info_t *epInfo;
        
        epInfo = &funcList[srcEP - 1];
	
	SendDataAddr.addrMode = (afAddrMode_t)Addr16Bit;         //短地址发送
	SendDataAddr.endPoint = dstEP;
	SendDataAddr.addr.shortAddr = addr;
        if ( AF_DataRequest( &SendDataAddr, //发送的地址和模式
                            // TODO:
               &epInfo->SampleApp_epDesc,   //终端（比如操作系统中任务ID等）
               SAMPLEAPP_PERIODIC_CLUSTERID,//发送串ID
               Leng,
               buf,
               &transID,  //信息ID（操作系统参数）
               AF_DISCV_ROUTE,
               AF_DEFAULT_RADIUS ) == afStatus_SUCCESS )
	{
                HalLedBlink( HAL_LED_1, 1, 50, 250 );
		return 1;
	}
	else
	{
		return 0;
	}
}
/*********************************************************************
*********************************************************************/
#endif
