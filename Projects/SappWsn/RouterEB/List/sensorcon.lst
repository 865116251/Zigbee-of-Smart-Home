###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.1.10194/W32 for 8051         18/May/2013  01:29:49 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Texas Instruments\ZStack-CC2530-IOT\Projects\Sa #
#                          ppWsn\Source\sensorcon.c                           #
#    Command line       =  -f "C:\Texas Instruments\ZStack-CC2530-IOT\Project #
#                          s\SappWsn\..\zstack\Tools\CC2530DB\f8wRouter.cfg"  #
#                          (-DCPU32MHZ -DROOT=__near_func                     #
#                          -DMAC_CFG_APP_PENDING_QUEUE=TRUE                   #
#                          -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8         #
#                          -DMAC_CFG_RX_MAX=5 -DRTR_NWK) -f "C:\Texas         #
#                          Instruments\ZStack-CC2530-IOT\Projects\SappWsn\..\ #
#                          zstack\Tools\CC2530DB\f8wConfig.cfg" (-DZIGBEEPRO  #
#                          -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR       #
#                          -DDEFAULT_CHANLIST=0x02000000                      #
#                          -DZDAPP_CONFIG_PAN_ID=31 -DNWK_START_DELAY=100     #
#                          -DEXTENDED_JOINING_RANDOM_MASK=0x007F              #
#                          -DBEACON_REQUEST_DELAY=100                         #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 "C:\Texas                   #
#                          Instruments\ZStack-CC2530-IOT\Projects\SappWsn\Sou #
#                          rce\sensorcon.c" -D ZTOOL_P1 -D MT_TASK -D         #
#                          MT_SYS_FUNC -D MT_ZDO_FUNC -D LCD_SUPPORTED=DEBUG  #
#                          -lC "C:\Texas Instruments\ZStack-CC2530-IOT\Projec #
#                          ts\SappWsn\RouterEB\List\" -lA "C:\Texas           #
#                          Instruments\ZStack-CC2530-IOT\Projects\SappWsn\Rou #
#                          terEB\List\" --diag_suppress Pe001,Pa010 -o        #
#                          "C:\Texas Instruments\ZStack-CC2530-IOT\Projects\S #
#                          appWsn\RouterEB\Obj\" -e --no_code_motion --debug  #
#                          --core=plain --dptr=16,1 --data_model=large        #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I "C:\Texas                  #
#                          Instruments\ZStack-CC2530-IOT\Projects\SappWsn\"   #
#                          -I "C:\Texas Instruments\ZStack-CC2530-IOT\Project #
#                          s\SappWsn\Source\" -I "C:\Texas                    #
#                          Instruments\ZStack-CC2530-IOT\Projects\SappWsn\..\ #
#                          zstack\ZMain\TI2530DB\" -I "C:\Texas               #
#                          Instruments\ZStack-CC2530-IOT\Projects\SappWsn\..\ #
#                          ..\Components\hal\include\" -I "C:\Texas           #
#                          Instruments\ZStack-CC2530-IOT\Projects\SappWsn\..\ #
#                          ..\Components\hal\target\CC2530EB\" -I "C:\Texas   #
#                          Instruments\ZStack-CC2530-IOT\Projects\SappWsn\..\ #
#                          ..\Components\mac\include\" -I "C:\Texas           #
#                          Instruments\ZStack-CC2530-IOT\Projects\SappWsn\..\ #
#                          ..\Components\mac\high_level\" -I "C:\Texas        #
#                          Instruments\ZStack-CC2530-IOT\Projects\SappWsn\..\ #
#                          ..\Components\mac\low_level\srf04\" -I "C:\Texas   #
#                          Instruments\ZStack-CC2530-IOT\Projects\SappWsn\..\ #
#                          ..\Components\mac\low_level\srf04\single_chip\"    #
#                          -I "C:\Texas Instruments\ZStack-CC2530-IOT\Project #
#                          s\SappWsn\..\..\Components\mt\" -I "C:\Texas       #
#                          Instruments\ZStack-CC2530-IOT\Projects\SappWsn\..\ #
#                          ..\Components\osal\include\" -I "C:\Texas          #
#                          Instruments\ZStack-CC2530-IOT\Projects\SappWsn\..\ #
#                          ..\Components\services\saddr\" -I "C:\Texas        #
#                          Instruments\ZStack-CC2530-IOT\Projects\SappWsn\..\ #
#                          ..\Components\services\sdata\" -I "C:\Texas        #
#                          Instruments\ZStack-CC2530-IOT\Projects\SappWsn\..\ #
#                          ..\Components\stack\af\" -I "C:\Texas              #
#                          Instruments\ZStack-CC2530-IOT\Projects\SappWsn\..\ #
#                          ..\Components\stack\nwk\" -I "C:\Texas             #
#                          Instruments\ZStack-CC2530-IOT\Projects\SappWsn\..\ #
#                          ..\Components\stack\sapi\" -I "C:\Texas            #
#                          Instruments\ZStack-CC2530-IOT\Projects\SappWsn\..\ #
#                          ..\Components\stack\sec\" -I "C:\Texas             #
#                          Instruments\ZStack-CC2530-IOT\Projects\SappWsn\..\ #
#                          ..\Components\stack\sys\" -I "C:\Texas             #
#                          Instruments\ZStack-CC2530-IOT\Projects\SappWsn\..\ #
#                          ..\Components\stack\zdo\" -I "C:\Texas             #
#                          Instruments\ZStack-CC2530-IOT\Projects\SappWsn\..\ #
#                          ..\Components\zmac\" -I "C:\Texas                  #
#                          Instruments\ZStack-CC2530-IOT\Projects\SappWsn\..\ #
#                          ..\Components\zmac\f8w\" -Ohz --require_prototypes #
#    List file          =  C:\Texas Instruments\ZStack-CC2530-IOT\Projects\Sa #
#                          ppWsn\RouterEB\List\sensorcon.lst                  #
#    Object file        =  C:\Texas Instruments\ZStack-CC2530-IOT\Projects\Sa #
#                          ppWsn\RouterEB\Obj\sensorcon.r51                   #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-CC2530-IOT\Projects\SappWsn\Source\sensorcon.c
      1          
      2          #include "hal_board.h"

   \                                 In  segment SFR_AN, at 0x80
   \   union <unnamed> volatile __sfr _A_P0
   \                     _A_P0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8c
   \   unsigned char volatile __sfr PICTL
   \                     PICTL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8d
   \   unsigned char volatile __sfr P1IEN
   \                     P1IEN:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8f
   \   unsigned char volatile __sfr P0INP
   \                     P0INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x90
   \   union <unnamed> volatile __sfr _A_P1
   \                     _A_P1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9a
   \   unsigned char volatile __sfr IEN2
   \                     IEN2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb4
   \   unsigned char volatile __sfr ADCCON1
   \                     ADCCON1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb6
   \   unsigned char volatile __sfr ADCCON3
   \                     ADCCON3:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xba
   \   unsigned char volatile __sfr ADCL
   \                     ADCL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbb
   \   unsigned char volatile __sfr ADCH
   \                     ADCH:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf2
   \   unsigned char volatile __sfr APCFG
   \                     APCFG:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf3
   \   unsigned char volatile __sfr P0SEL
   \                     P0SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf4
   \   unsigned char volatile __sfr P1SEL
   \                     P1SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf6
   \   unsigned char volatile __sfr P1INP
   \                     P1INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf7
   \   unsigned char volatile __sfr P2INP
   \                     P2INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfd
   \   unsigned char volatile __sfr P0DIR
   \                     P0DIR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfe
   \   unsigned char volatile __sfr P1DIR
   \                     P1DIR:
   \   000000                DS 1
      3          #include "hal_defs.h"
      4          #include "hal_mcu.h"
      5          #include "hal_types.h"
      6          #include "sensorcon.h"
      7          #include  "hal_adc.h"
      8          
      9          #define		SHT1DATA_HIGH	P1 |= 0x40
     10          #define		SHT1DATA_LOW	P1 &= 0xBF
     11          
     12          #define		SHT1SCK_HIGH	P1 |= 0x80
     13          #define		SHT1SCK_LOW	P1 &= 0x7F
     14          
     15          #define         SHT1READY       (P1>>6)&0X1
     16          /*****************************************************************************
     17           函数声明
     18          *****************************************************************************/
     19          void Sensor_PIN_INT(uint8);
     20          uint16 ReadAdcValue(uint8 ChannelNum,uint8 DecimationRate,uint8 RefVoltage);
     21          void SHT1_Reset(void);
     22          void SHT1_Start(void);
     23          void SHT1_SendAck(void);
     24          void SHT1_WriteCommandData(uint8);
     25          uint8 SHT1_ReadData(void);
     26          uint8 SHT1_Ready(void);
     27          void SHT1_WriteReg(uint8);
     28          uint16 SHT1_ReadReg(void);
     29          void SHT1_INT(void);
     30          uint32 ReadSHT1(uint8 Addr);
     31          uint8 ReadTc77(void);
     32          void SET_ADC_IO_SLEEP_MODE(void);
     33          void SET_ADC_IO_ADC_MODE(void);
     34          extern void UartTX_Send_String(uint8 *Data,int len);
     35          uint8 CRC8(uint8 crc, uint8 data);
     36          /*****************************************************************************
     37           void SET_ADC_IO_SLEEP_MODE(void)
     38          
     39            设置ADC I/O口为低功耗模式.
     40          *****************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     41          void SET_ADC_IO_SLEEP_MODE(void)
   \                     SET_ADC_IO_SLEEP_MODE:
     42          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     43            P0SEL &= ~(1<<0);    // 
   \   000000   53F3FE       ANL     0xf3,#0xfe
     44            P0    &= ~(1<<0);
   \   000003   C280         CLR     0x80.0
     45            P0DIR &= ~(1<<0);
   \   000005   53FDFE       ANL     0xfd,#0xfe
     46            P0INP |= (1<<0);
   \   000008   438F01       ORL     0x8f,#0x1
     47                     
     48            P0SEL &= ~(1<<1);    // adc关闭
   \   00000B   53F3FD       ANL     0xf3,#0xfd
     49            P0    &= ~(1<<1);
   \   00000E   C281         CLR     0x80.1
     50            P0DIR &= ~(1<<1);
   \   000010   53FDFD       ANL     0xfd,#0xfd
     51            P0INP |= (1<<1);
   \   000013   438F02       ORL     0x8f,#0x2
     52            
     53            P0SEL &= ~(1<<6);    // 
   \   000016   53F3BF       ANL     0xf3,#0xbf
     54            P0    &= ~(1<<6);
   \   000019   C286         CLR     0x80.6
     55            P0DIR &= ~(1<<6);
   \   00001B   53FDBF       ANL     0xfd,#0xbf
     56            P0INP |= (1<<6);
   \   00001E   438F40       ORL     0x8f,#0x40
     57                     
     58            P0SEL &= ~(1<<7);    // 
   \   000021   53F37F       ANL     0xf3,#0x7f
     59            P0    &= ~(1<<7);
   \   000024   C287         CLR     0x80.7
     60            P0DIR &= ~(1<<7);
   \   000026   53FD7F       ANL     0xfd,#0x7f
     61            P0INP |= (1<<7);
   \   000029   438F80       ORL     0x8f,#0x80
     62                     
     63            APCFG &= ~0xC3;
   \   00002C   53F23C       ANL     0xf2,#0x3c
     64          }
   \   00002F   02....       LJMP    ?BRET
   \   000032                REQUIRE P0SEL
   \   000032                REQUIRE _A_P0
   \   000032                REQUIRE P0DIR
   \   000032                REQUIRE P0INP
   \   000032                REQUIRE APCFG
     65          
     66          /*函数功能:读出AD口的数据
     67          输入参数:ChannelNum:采集的通道号  0-0xF
     68                              1000: AIN0CAIN1
     69                              1001: AIN2CAIN3
     70                              1010: AIN4CAIN5
     71                              1011: AIN6CAIN7
     72                              1100: GND
     73                              1101: Reserved
     74                              1110: Temperature sensor
     75                              1111: VDD/3
     76                   DecimationRate:分辩率  00: 64 decimation rate (7 bits ENOB)
     77                              01: 128 decimation rate (9 bits ENOB)
     78                              10: 256 decimation rate (10 bits ENOB)
     79                              11: 512 decimation rate (12 bits ENOB)
     80          RefVoltage:参考电压:00: Internal reference
     81                              01: External reference on AIN7 pin
     82                              10: AVDD5 pin
     83                              11: External reference on AIN6CAIN7 differential input
     84          返回值:16bit的采集数据
     85          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     86          uint16 ReadAdcValue(uint8 ChannelNum,uint8 DecimationRate,uint8 RefVoltage)
   \                     ReadAdcValue:
     87          { 
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FC           MOV     R4,A
   \   000007   EB           MOV     A,R3
   \   000008   FD           MOV     R5,A
     88            uint16 AdValue;
     89            if(ChannelNum == 0xe){//片内温度到ADC_SOC
   \   000009   740E         MOV     A,#0xe
   \   00000B   69           XRL     A,R1
   \   00000C   90624B       MOV     DPTR,#0x624b
   \   00000F   7004         JNZ     ??ReadAdcValue_0
     90              TR0 = 1;
   \   000011   7401         MOV     A,#0x1
   \   000013   8001         SJMP    ??ReadAdcValue_1
     91              ATEST = 1;
     92            }
     93            else{
     94              TR0 = 0;
   \                     ??ReadAdcValue_0:
   \   000015   E4           CLR     A
   \                     ??ReadAdcValue_1:
   \   000016   F0           MOVX    @DPTR,A
     95              ATEST = 0;
   \   000017   9061BD       MOV     DPTR,#0x61bd
   \   00001A   F0           MOVX    @DPTR,A
     96            } 
     97            ADCCON3 = ChannelNum&0xf;
   \   00001B   740F         MOV     A,#0xf
   \   00001D   59           ANL     A,R1
   \   00001E   F5B6         MOV     0xb6,A
     98            ADCCON3 = ADCCON3 | ((DecimationRate&0x3)<<4);
   \   000020   7403         MOV     A,#0x3
   \   000022   5C           ANL     A,R4
   \   000023   C4           SWAP    A
   \   000024   42B6         ORL     0xb6,A
     99            ADCCON3 = ADCCON3 | ((RefVoltage&0x3)<<6);   
   \   000026   ED           MOV     A,R5
   \   000027   C4           SWAP    A
   \   000028   33           RLC     A
   \   000029   33           RLC     A
   \   00002A   54C0         ANL     A,#0xc0
   \   00002C   42B6         ORL     0xb6,A
    100            ADCCON1 = ADCCON1 | (0x3<<4);//ADCCON1.ST = 1时启动
   \   00002E   43B430       ORL     0xb4,#0x30
    101            AdValue = ADCL; //清除EOC 
   \   000031   E5BA         MOV     A,0xba
    102            AdValue = ADCH; 
   \   000033   E5BB         MOV     A,0xbb
    103            ADCCON1 = ADCCON1 | (0x1<<6);//启动转换
   \   000035   43B440       ORL     0xb4,#0x40
    104            while(!(ADCCON1&0x80));
   \                     ??ReadAdcValue_2:
   \   000038   E5B4         MOV     A,0xb4
   \   00003A   A2E7         MOV     C,0xE0 /* A   */.7
   \   00003C   50FA         JNC     ??ReadAdcValue_2
    105            AdValue = ADCH;
   \   00003E   E5BB         MOV     A,0xbb
   \   000040   F5..         MOV     ?V0 + 0,A
    106            AdValue = (AdValue<<6) + (ADCL>>2);
   \   000042   E5BA         MOV     A,0xba
   \   000044   FA           MOV     R2,A
    107            ADCCON1 =  ADCCON1 & 0x7f;
   \   000045   53B47F       ANL     0xb4,#0x7f
    108            return AdValue;
   \   000048   75..00       MOV     ?V0 + 1,#0x0
   \   00004B   7406         MOV     A,#0x6
   \   00004D   78..         MOV     R0,#?V0 + 0
   \   00004F   12....       LCALL   ?S_SHL
   \   000052   EA           MOV     A,R2
   \   000053   13           RRC     A
   \   000054   13           RRC     A
   \   000055   543F         ANL     A,#0x3f
   \   000057   FA           MOV     R2,A
   \   000058   E5..         MOV     A,?V0 + 0
   \   00005A   2A           ADD     A,R2
   \   00005B   FA           MOV     R2,A
   \   00005C   E5..         MOV     A,?V0 + 1
   \   00005E   3400         ADDC    A,#0x0
   \   000060                REQUIRE ?Subroutine0
   \   000060                REQUIRE ADCCON3
   \   000060                REQUIRE ADCCON1
   \   000060                REQUIRE ADCL
   \   000060                REQUIRE ADCH
   \   000060                ; // Fall through to label ?Subroutine0
    109          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   FB           MOV     R3,A
   \   000001   7F02         MOV     R7,#0x2
   \   000003   02....       LJMP    ?BANKED_LEAVE_XDATA
    110          /*****************************************************************************
    111            void Sensor_PIN_INT(void)
    112          
    113            传感器及ADC I/O口初始化.
    114          *****************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    115          void Sensor_PIN_INT(uint8 SensorType)
   \                     Sensor_PIN_INT:
    116          {	
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    117            if(SensorType == 1)
   \   000000   7401         MOV     A,#0x1
   \   000002   69           XRL     A,R1
   \   000003   7006         JNZ     ??Sensor_PIN_INT_0
    118              APCFG = (0x1<<1)|(0x1<<4)|(0x1<<5)|(0x1<<6)|(0x1<<7);//P04,P05,P06,P07为ADC口            
   \   000005   75F2F2       MOV     0xf2,#-0xe
   \   000008   02....       LJMP    ??Sensor_PIN_INT_1 & 0xFFFF
    119            else if(SensorType == 2){
   \                     ??Sensor_PIN_INT_0:
   \   00000B   7402         MOV     A,#0x2
   \   00000D   69           XRL     A,R1
   \   00000E   7012         JNZ     ??Sensor_PIN_INT_2
    120              APCFG = (0x1<<1)|(0x1<<4)|(0x1<<5)|(0x1<<6)|(0x1<<7);//P04,P05,P06,P07为ADC口            
   \   000010   75F2F2       MOV     0xf2,#-0xe
    121              P1INP &= (~(0x1 | (0x1<<1) | (0x1<<2) | (0x1<<6)));//P1.0,P1.1,P1.2,P1.6上拉 
   \   000013   53F6B8       ANL     0xf6,#0xb8
    122              P1SEL &= ~((1<<3)|(1<<4)|(1<<5)|(1<<6)|(1<<7));//P13,P14,P15,P16,P17为GPIO        
   \   000016   53F407       ANL     0xf4,#0x7
    123              P1DIR |= ((1<<3)|(1<<4)|(1<<5)|(1<<6));//P13,P14,P15,P16为OUTPUT  
   \   000019   43FE78       ORL     0xfe,#0x78
    124              P1DIR &= ~(1<<7);//P17为INPUT              
   \   00001C   53FE7F       ANL     0xfe,#0x7f
   \   00001F   02....       LJMP    ??Sensor_PIN_INT_1 & 0xFFFF
    125            }
    126            else if(SensorType == 3){
   \                     ??Sensor_PIN_INT_2:
   \   000022   7403         MOV     A,#0x3
   \   000024   69           XRL     A,R1
   \   000025   7021         JNZ     ??Sensor_PIN_INT_3
    127              APCFG = ((0x1<<5)|(0x1<<6));//P05,P06为ADC口            
   \   000027   75F260       MOV     0xf2,#0x60
    128              P1INP &= (~(0x1 | (0x1<<1) | (0x1<<2) | (0x1<<6)));//P1.0,P1.1,P1.2,P1.6上拉 
   \   00002A   53F6B8       ANL     0xf6,#0xb8
    129              P1SEL &= ~((1<<3)|(1<<4)|(1<<5)|(1<<7));//P13,P14,P15,P16,P17为GPIO        
   \   00002D   53F447       ANL     0xf4,#0x47
    130              P1DIR |= ((1<<3)|(1<<4)|(1<<5));//P13,P14,P15为OUTPUT  
   \   000030   43FE38       ORL     0xfe,#0x38
    131              P1DIR &= ~(1<<7);//P17为INPUT              
   \   000033   53FE7F       ANL     0xfe,#0x7f
    132              
    133              P1SEL |= (1<<6);//P16为外设功能       
   \   000036   43F440       ORL     0xf4,#0x40
    134              PICTL &= ~(1<<2); //P14~P17上升沿触发
   \   000039   538CFB       ANL     0x8c,#0xfb
    135              P1IEN |= (1<<6);//P16中断使能
   \   00003C   438D40       ORL     0x8d,#0x40
    136              IEN2 |= (1<<4);//P1口中断使能
   \   00003F   439A10       ORL     0x9a,#0x10
    137              P1 &= ~((1<<3)|(1<<4));//00:正,负管均不通  
   \   000042   5390E7       ANL     0x90,#0xe7
   \   000045   02....       LJMP    ??Sensor_PIN_INT_1 & 0xFFFF
    138            }
    139            else if(SensorType == 5){
   \                     ??Sensor_PIN_INT_3:
   \   000048   7405         MOV     A,#0x5
   \   00004A   69           XRL     A,R1
   \   00004B   7006         JNZ     ??Sensor_PIN_INT_4
    140              APCFG = ((0x1<<5)|(0x1<<6)|(0x1<<7));//P05,P06,P07为ADC口            
   \   00004D   75F2E0       MOV     0xf2,#-0x20
   \   000050   02....       LJMP    ??Sensor_PIN_INT_1 & 0xFFFF
    141            }
    142            else if(SensorType == 6){//Motor,Step Motor    
   \                     ??Sensor_PIN_INT_4:
   \   000053   7406         MOV     A,#0x6
   \   000055   69           XRL     A,R1
   \   000056   7014         JNZ     ??Sensor_PIN_INT_5
    143              P1SEL = 0;   //P10,P11,P12,P13,P14,P15,P16,P17为GPIO        
   \   000058   75F400       MOV     0xf4,#0x0
    144              P1DIR = 0xff;//P10,P11,P12,P13,P14,P15,P16,P17为OUTPUT      
   \   00005B   75FEFF       MOV     0xfe,#-0x1
    145              P0SEL &= ~((1<<4)|(1<<5)|(1<<6));//P04,P05,P06为GPIO    
   \   00005E   53F38F       ANL     0xf3,#0x8f
    146              P0DIR |= ((1<<4)|(1<<5)|(1<<6)); //P04,P05,P06为OUTPUT
   \   000061   43FD70       ORL     0xfd,#0x70
    147              P0 &= ~((1<<4)|(1<<5)|(1<<6));
   \   000064   53808F       ANL     0x80,#0x8f
    148              APCFG = (0x1<<1);//P01为ADC口    
   \                     ??Sensor_PIN_INT_6:
   \   000067   75F202       MOV     0xf2,#0x2
   \   00006A   8069         SJMP    ??Sensor_PIN_INT_1
    149            }
    150            else if(SensorType == 7){//SEG显示,MATRIX LEDs    
   \                     ??Sensor_PIN_INT_5:
   \   00006C   7407         MOV     A,#0x7
   \   00006E   69           XRL     A,R1
   \   00006F   7011         JNZ     ??Sensor_PIN_INT_7
    151              P1SEL = 0;   //P10,P11,P12,P13,P14,P15,P16,P17为GPIO        
   \   000071   75F400       MOV     0xf4,#0x0
    152              P1DIR = 0xff;//P10,P11,P12,P13,P14,P15,P16,P17为OUTPUT  
   \   000074   75FEFF       MOV     0xfe,#-0x1
    153              P0SEL &= ~((1<<4)|(1<<5)|(1<<6)|(1<<7));//P04,P05,P06,P07为GPIO    
   \   000077   53F30F       ANL     0xf3,#0xf
    154              P0DIR |= ((1<<4)|(1<<5)|(1<<6)|(1<<7));//P04,P05,P06,P07为OUTPUT        
   \   00007A   43FDF0       ORL     0xfd,#0xf0
    155              P0 &= ~((1<<4)|(1<<5)|(1<<6)|(1<<7));
   \   00007D   53800F       ANL     0x80,#0xf
    156              APCFG = (0x1<<1);//P01为ADC口    
   \   000080   80E5         SJMP    ??Sensor_PIN_INT_6
    157            }
    158            else if(SensorType == 8){//传感器类型8  心电P0.5,模拟量；脉搏P0.6,数字量
   \                     ??Sensor_PIN_INT_7:
   \   000082   7408         MOV     A,#0x8
   \   000084   69           XRL     A,R1
   \   000085   7014         JNZ     ??Sensor_PIN_INT_8
    159              P1SEL = 0;   //P10,P11,P12,P13,P14,P15,P16,P17为GPIO        
   \   000087   75F400       MOV     0xf4,#0x0
    160              P1DIR = 0xff;//P10,P11,P12,P13,P14,P15,P16,P17为OUTPUT  
   \   00008A   75FEFF       MOV     0xfe,#-0x1
    161              P1DIR &= ~(1<<4);//P14为INPUT              
   \   00008D   53FEEF       ANL     0xfe,#0xef
    162              P0SEL &= ~((1<<4)|(1<<5)|(1<<6)|(1<<7));//P04,P05,P06,P07为GPIO        
   \   000090   53F30F       ANL     0xf3,#0xf
    163              P0DIR &= ~(1<<6);//P0.6为INPUT              
   \   000093   53FDBF       ANL     0xfd,#0xbf
    164              APCFG = (0x1<<5);//P0.5为ADC口    
   \   000096   75F220       MOV     0xf2,#0x20
   \   000099   803A         SJMP    ??Sensor_PIN_INT_1
    165            }
    166            else if(SensorType == 9){//传感器类型9 紫外线P0.4,模拟量；红外线P0.5,数字量；门磁P1.4,数字量
   \                     ??Sensor_PIN_INT_8:
   \   00009B   7409         MOV     A,#0x9
   \   00009D   69           XRL     A,R1
   \   00009E   7014         JNZ     ??Sensor_PIN_INT_9
    167              P1SEL = 0;   //P10,P11,P12,P13,P14,P15,P16,P17为GPIO        
   \   0000A0   75F400       MOV     0xf4,#0x0
    168              P1DIR = 0xff;//P10,P11,P12,P13,P14,P15,P16,P17为OUTPUT  
   \   0000A3   75FEFF       MOV     0xfe,#-0x1
    169              P1DIR &= ~(1<<4);//P14为INPUT              
   \   0000A6   53FEEF       ANL     0xfe,#0xef
    170              P0SEL &= ~((1<<4)|(1<<5)|(1<<6)|(1<<7));//P04,P05,P06,P07为GPIO        
   \   0000A9   53F30F       ANL     0xf3,#0xf
    171              P0DIR &= ~(1<<5);//P0.5为INPUT              
   \   0000AC   53FDDF       ANL     0xfd,#0xdf
    172              APCFG = (0x1<<4);//P0.4为ADC口    
   \   0000AF   75F210       MOV     0xf2,#0x10
   \   0000B2   8021         SJMP    ??Sensor_PIN_INT_1
    173            }
    174            else{//SensorType为0等其它情况
    175              //用于传感器类型的读取
    176              P2INP &= (~(1<<6)); //P1口上拉使能        
   \                     ??Sensor_PIN_INT_9:
   \   0000B4   53F7BF       ANL     0xf7,#0xbf
    177              P1INP &= (~(0x1 | (0x1<<1) | (0x1<<2) | (0x1<<6) | (0x1<<7)));//P1.0,P1.1,P1.2,P1.6,P1.7上拉 
   \   0000B7   53F638       ANL     0xf6,#0x38
    178              
    179              //用于人体感应的读取
    180              P0SEL &= ~(1<<5);//P05为GPIO    
   \   0000BA   53F3DF       ANL     0xf3,#0xdf
    181              P0DIR &= ~(1<<5);//P05为INPUT    
   \   0000BD   53FDDF       ANL     0xfd,#0xdf
    182              APCFG = (0x1<1)|(0x1<<4)|(0x1<<6);//P01,P04,P06为ADC口       
   \   0000C0   75F250       MOV     0xf2,#0x50
    183             
    184              //用于温湿度测量
    185              P1SEL &= ~((1<<6)|(1<<7));//P16,P17为GPIO        
   \   0000C3   53F43F       ANL     0xf4,#0x3f
    186              P1DIR |= (1<<6)|(1<<7);//P16,P17为OUTPUT    
   \   0000C6   43FEC0       ORL     0xfe,#0xc0
    187              
    188              P1SEL |= (1<<3);//P13为外设功能       
   \   0000C9   43F408       ORL     0xf4,#0x8
    189              PICTL &= ~(1<<1); //P10~P13上升沿触发
   \   0000CC   538CFD       ANL     0x8c,#0xfd
    190              P1IEN |= (1<<3);//P13中断使能
   \   0000CF   438D08       ORL     0x8d,#0x8
    191              IEN2 |= (1<<4);//P1口中断使能
   \   0000D2   439A10       ORL     0x9a,#0x10
    192            }  
    193          }
   \                     ??Sensor_PIN_INT_1:
   \   0000D5   02....       LJMP    ?BRET
   \   0000D8                REQUIRE APCFG
   \   0000D8                REQUIRE P1INP
   \   0000D8                REQUIRE P1SEL
   \   0000D8                REQUIRE P1DIR
   \   0000D8                REQUIRE PICTL
   \   0000D8                REQUIRE P1IEN
   \   0000D8                REQUIRE IEN2
   \   0000D8                REQUIRE _A_P1
   \   0000D8                REQUIRE P0SEL
   \   0000D8                REQUIRE P0DIR
   \   0000D8                REQUIRE _A_P0
   \   0000D8                REQUIRE P2INP
    194          
    195          //当uC和SHT10通信中断时,复位通信口

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    196          void SHT1_Reset(void)
   \                     SHT1_Reset:
    197          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    198            uint8 i;
    199            
    200            SHT1DATA_HIGH;
   \   000000   D296         SETB    0x90.6
    201            for(i=0;i<10;i++){
   \   000002   740A         MOV     A,#0xa
    202              SHT1SCK_LOW;
   \                     ??SHT1_Reset_0:
   \   000004   C297         CLR     0x90.7
    203              SHT1SCK_HIGH;    
   \   000006   D297         SETB    0x90.7
    204            }  
   \   000008   14           DEC     A
   \   000009   70F9         JNZ     ??SHT1_Reset_0
    205          }
   \   00000B   02....       LJMP    ?BRET
   \   00000E                REQUIRE _A_P1
    206          
    207          //传输启始信号

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    208          void SHT1_Start(void)
   \                     SHT1_Start:
    209          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    210            SHT1DATA_HIGH;
   \   000000   D296         SETB    0x90.6
    211            SHT1SCK_HIGH;
   \   000002   D297         SETB    0x90.7
    212            SHT1DATA_LOW;
   \   000004   C296         CLR     0x90.6
    213            SHT1SCK_LOW;
   \   000006   C297         CLR     0x90.7
    214            SHT1SCK_HIGH;
   \   000008   D297         SETB    0x90.7
    215            SHT1DATA_HIGH;  
   \   00000A   D296         SETB    0x90.6
    216          }
   \   00000C   02....       LJMP    ?BRET
   \   00000F                REQUIRE _A_P1
    217          
    218          //为0时,写命令正确;为1时错误

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    219          uint8 SHT1_Ready(void)
   \                     SHT1_Ready:
    220          {  
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    221            //读应答信号
    222            SHT1DATA_HIGH;
   \   000000   D296         SETB    0x90.6
    223            return(SHT1READY);
   \   000002   A296         MOV     C,0x90.6
   \   000004   E4           CLR     A
   \   000005   33           RLC     A
   \   000006   F9           MOV     R1,A
   \   000007   02....       LJMP    ?BRET
   \   00000A                REQUIRE _A_P1
    224          }
    225          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    226          void SHT1_SendAck(void)
   \                     SHT1_SendAck:
    227          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    228            SHT1SCK_HIGH;
   \   000000   D297         SETB    0x90.7
    229            SHT1SCK_LOW;    
   \   000002   C297         CLR     0x90.7
    230          }
   \   000004   02....       LJMP    ?BRET
   \   000007                REQUIRE _A_P1
    231          //为0时,写命令正确;为1时错误

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    232          void SHT1_WriteCommandData(uint8 bCommand)
   \                     SHT1_WriteCommandData:
    233          {
   \   000000   C0..         PUSH    ?V0 + 0
   \   000002   C0..         PUSH    ?V0 + 1
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    234            uint8 i;  
    235            SHT1SCK_LOW;
   \   000004   C297         CLR     0x90.7
    236            for(i=0;i<8;i++){
   \   000006   7A00         MOV     R2,#0x0
    237              if(bCommand&(0x1<<(7-i)))
   \                     ??SHT1_WriteCommandData_0:
   \   000008   75..01       MOV     ?V0 + 0,#0x1
   \   00000B   75..00       MOV     ?V0 + 1,#0x0
   \   00000E   7407         MOV     A,#0x7
   \   000010   C3           CLR     C
   \   000011   9A           SUBB    A,R2
   \   000012   78..         MOV     R0,#?V0 + 0
   \   000014   12....       LCALL   ?S_SHL
   \   000017   E5..         MOV     A,?V0 + 0
   \   000019   59           ANL     A,R1
   \   00001A   6004         JZ      ??SHT1_WriteCommandData_1
    238                SHT1DATA_HIGH;
   \   00001C   D296         SETB    0x90.6
   \   00001E   8002         SJMP    ??SHT1_WriteCommandData_2
    239              else
    240                SHT1DATA_LOW;
   \                     ??SHT1_WriteCommandData_1:
   \   000020   C296         CLR     0x90.6
    241              SHT1SCK_HIGH;
   \                     ??SHT1_WriteCommandData_2:
   \   000022   D297         SETB    0x90.7
    242              SHT1SCK_LOW;     
   \   000024   C297         CLR     0x90.7
    243            }
   \   000026   0A           INC     R2
   \   000027   EA           MOV     A,R2
   \   000028   C3           CLR     C
   \   000029   9408         SUBB    A,#0x8
   \   00002B   40DB         JC      ??SHT1_WriteCommandData_0
    244          }
   \   00002D   D0..         POP     ?V0 + 1
   \   00002F   D0..         POP     ?V0 + 0
   \   000031   02....       LJMP    ?BRET
   \   000034                REQUIRE _A_P1
    245          
    246          //读一个字节的数据

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    247          uint8 SHT1_ReadData(void)
   \                     SHT1_ReadData:
    248          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
    249            uint8 i,bResult;
    250            bResult = 0;
   \   000005   75..00       MOV     ?V0 + 0,#0x0
    251            SHT1DATA_HIGH;
   \   000008   D296         SETB    0x90.6
    252            for(i=0;i<8;i++){      
   \   00000A   7E00         MOV     R6,#0x0
    253              if(SHT1_Ready() != 0)
   \                     ??SHT1_ReadData_0:
   \   00000C                ; Setup parameters for call to function SHT1_Ready
   \   00000C   12....       LCALL   ??SHT1_Ready?relay
   \   00000F   E9           MOV     A,R1
   \   000010   6013         JZ      ??SHT1_ReadData_1
    254                bResult |= (0x1<<(7-i));     
   \   000012   75..01       MOV     ?V0 + 2,#0x1
   \   000015   75..00       MOV     ?V0 + 3,#0x0
   \   000018   7407         MOV     A,#0x7
   \   00001A   C3           CLR     C
   \   00001B   9E           SUBB    A,R6
   \   00001C   78..         MOV     R0,#?V0 + 2
   \   00001E   12....       LCALL   ?S_SHL
   \   000021   E5..         MOV     A,?V0 + 2
   \   000023   42..         ORL     ?V0 + 0,A
    255              SHT1SCK_HIGH;
   \                     ??SHT1_ReadData_1:
   \   000025   D297         SETB    0x90.7
    256              SHT1SCK_LOW; 
   \   000027   C297         CLR     0x90.7
    257            }
   \   000029   0E           INC     R6
   \   00002A   EE           MOV     A,R6
   \   00002B   C3           CLR     C
   \   00002C   9408         SUBB    A,#0x8
   \   00002E   40DC         JC      ??SHT1_ReadData_0
    258            return bResult;
   \   000030   A9..         MOV     R1,?V0 + 0
   \   000032   7F04         MOV     R7,#0x4
   \   000034   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000037                REQUIRE _A_P1
    259          }
    260          
    261          //写状态寄存器

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    262          void SHT1_WriteReg(uint8 Value)
   \                     SHT1_WriteReg:
    263          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   \   000007   8003         SJMP    ??SHT1_WriteReg_0
    264            while(1){    
    265              SHT1_Start();  
    266              SHT1_WriteCommandData(6);
    267              if(SHT1_Ready() != 0){  //无应答
    268                SHT1_Reset();  
   \                     ??SHT1_WriteReg_1:
   \   000009                ; Setup parameters for call to function SHT1_Reset
   \   000009   12....       LCALL   ??SHT1_Reset?relay
    269                continue;
    270              }
   \                     ??SHT1_WriteReg_0:
   \   00000C                ; Setup parameters for call to function SHT1_Start
   \   00000C   12....       LCALL   ??SHT1_Start?relay
   \   00000F                ; Setup parameters for call to function SHT1_WriteCommandData
   \   00000F   7906         MOV     R1,#0x6
   \   000011   12....       LCALL   ??Subroutine4_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   000014   70F3         JNZ     ??SHT1_WriteReg_1
    271              else
    272                SHT1_SendAck();    
   \   000016                ; Setup parameters for call to function SHT1_SendAck
   \   000016   12....       LCALL   ??SHT1_SendAck?relay
    273              SHT1_WriteCommandData(Value);
   \   000019                ; Setup parameters for call to function SHT1_WriteCommandData
   \   000019   12....       LCALL   ?Subroutine1 & 0xFFFF
    274              if(SHT1_Ready() != 0){  //无应答
   \                     ??CrossCallReturnLabel_2:
   \   00001C   70EB         JNZ     ??SHT1_WriteReg_1
    275                SHT1_Reset(); 
    276                continue;
    277              }
    278              else
    279                SHT1_SendAck();   
   \   00001E                ; Setup parameters for call to function SHT1_SendAck
   \   00001E   12....       LCALL   ??SHT1_SendAck?relay
    280              break;
    281            }   
    282          }
   \   000021   7F01         MOV     R7,#0x1
   \   000023   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   EE           MOV     A,R6
   \   000001   F9           MOV     R1,A
   \   000002                REQUIRE ??Subroutine4_0
   \   000002                ; // Fall through to label ??Subroutine4_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine4_0:
   \   000000   12....       LCALL   ??SHT1_WriteCommandData?relay
   \   000003                ; Setup parameters for call to function SHT1_Ready
   \   000003                ; Setup parameters for call to function SHT1_Ready
   \   000003                ; Setup parameters for call to function SHT1_Ready
   \   000003                ; Setup parameters for call to function SHT1_Ready
   \   000003   12....       LCALL   ??SHT1_Ready?relay
   \   000006   E9           MOV     A,R1
   \   000007   22           RET
    283          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    284          uint16 SHT1_ReadReg(void)
   \                     SHT1_ReadReg:
    285          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   8003         SJMP    ??SHT1_ReadReg_0
    286            uint16 lResult;
    287            while(1){     
    288              SHT1_Start();  
    289              SHT1_WriteCommandData(7);
    290              if(SHT1_Ready() != 0){  //无应答
    291                SHT1_Reset();        
   \                     ??SHT1_ReadReg_1:
   \   000007                ; Setup parameters for call to function SHT1_Reset
   \   000007   12....       LCALL   ??SHT1_Reset?relay
    292                continue;      
    293              }
   \                     ??SHT1_ReadReg_0:
   \   00000A                ; Setup parameters for call to function SHT1_Start
   \   00000A   12....       LCALL   ??SHT1_Start?relay
   \   00000D                ; Setup parameters for call to function SHT1_WriteCommandData
   \   00000D   7907         MOV     R1,#0x7
   \   00000F   12....       LCALL   ??Subroutine4_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   000012   70F3         JNZ     ??SHT1_ReadReg_1
    294              else{
    295                SHT1_SendAck();
   \   000014                ; Setup parameters for call to function SHT1_SendAck
   \   000014   12....       LCALL   ??Subroutine5_0 & 0xFFFF
    296                break;
    297              }    
    298            } 
    299            
    300            lResult = (SHT1_ReadData()<<8);  
   \                     ??CrossCallReturnLabel_8:
   \   000017   FE           MOV     R6,A
    301            SHT1DATA_LOW;
   \   000018   12....       LCALL   ?Subroutine2 & 0xFFFF
    302            SHT1_SendAck();
    303                
    304            lResult |= SHT1_ReadData(); 
    305            SHT1DATA_HIGH;
   \                     ??CrossCallReturnLabel_0:
   \   00001B   D296         SETB    0x90.6
    306            SHT1_SendAck();
   \   00001D                ; Setup parameters for call to function SHT1_SendAck
   \   00001D   12....       LCALL   ??SHT1_SendAck?relay
    307              
    308            return lResult;
   \   000020   EE           MOV     A,R6
   \   000021   AA..         MOV     R2,?V0 + 0
   \   000023   02....       LJMP    ?Subroutine0 & 0xFFFF
   \   000026                REQUIRE _A_P1
    309          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   C296         CLR     0x90.6
   \   000002                ; Setup parameters for call to function SHT1_SendAck
   \   000002                ; Setup parameters for call to function SHT1_SendAck
   \   000002                ; Setup parameters for call to function SHT1_SendAck
   \   000002                REQUIRE ??Subroutine5_0
   \   000002                ; // Fall through to label ??Subroutine5_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine5_0:
   \   000000   12....       LCALL   ??SHT1_SendAck?relay
   \   000003                ; Setup parameters for call to function SHT1_ReadData
   \   000003                ; Setup parameters for call to function SHT1_ReadData
   \   000003                ; Setup parameters for call to function SHT1_ReadData
   \   000003                ; Setup parameters for call to function SHT1_ReadData
   \   000003   12....       LCALL   ??SHT1_ReadData?relay
   \   000006   E9           MOV     A,R1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   000003   F5..         MOV     ?V0 + 0,A
   \   000005   22           RET
    310          
    311          /*
    312          void SHT1_INT(void)
    313          {
    314              
    315          }*/
    316          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    317          uint32 ReadSHT1(uint8 Addr)
   \                     ReadSHT1:
    318          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   \   000007   8003         SJMP    ??ReadSHT1_0
    319            uint32 lResult;
    320            while(1){     
    321              SHT1_Start();  
    322              SHT1_WriteCommandData(Addr);
    323              if(SHT1_Ready() != 0){  //无应答
    324                SHT1_Reset();  
   \                     ??ReadSHT1_1:
   \   000009                ; Setup parameters for call to function SHT1_Reset
   \   000009   12....       LCALL   ??SHT1_Reset?relay
    325                continue;      
    326              }
   \                     ??ReadSHT1_0:
   \   00000C                ; Setup parameters for call to function SHT1_Start
   \   00000C   12....       LCALL   ??SHT1_Start?relay
   \   00000F                ; Setup parameters for call to function SHT1_WriteCommandData
   \   00000F   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   000012   70F5         JNZ     ??ReadSHT1_1
    327              else{
    328                SHT1_SendAck();
   \   000014                ; Setup parameters for call to function SHT1_SendAck
   \   000014   12....       LCALL   ??SHT1_SendAck?relay
    329                break;
    330              }    
    331            }
    332            
    333            while(SHT1_Ready() == 1);
   \                     ??ReadSHT1_2:
   \   000017                ; Setup parameters for call to function SHT1_Ready
   \   000017   12....       LCALL   ??SHT1_Ready?relay
   \   00001A   E9           MOV     A,R1
   \   00001B   6401         XRL     A,#0x1
   \   00001D   60F8         JZ      ??ReadSHT1_2
    334            lResult = SHT1_ReadData();  
   \   00001F                ; Setup parameters for call to function SHT1_ReadData
   \   00001F   12....       LCALL   ??SHT1_ReadData?relay
   \   000022   E9           MOV     A,R1
   \   000023   F5..         MOV     ?V0 + 4,A
    335            lResult = lResult<<16;
    336            SHT1DATA_LOW;
   \   000025   12....       LCALL   ?Subroutine2 & 0xFFFF
    337            SHT1_SendAck();
    338                
    339            lResult |= ((uint16)SHT1_ReadData()<<8); 
    340            SHT1DATA_LOW;
   \                     ??CrossCallReturnLabel_1:
   \   000028   12....       LCALL   ?Subroutine3 & 0xFFFF
    341            SHT1_SendAck();
    342              
    343            lResult |= SHT1_ReadData(); 
   \                     ??CrossCallReturnLabel_6:
   \   00002B   FF           MOV     R7,A
    344            SHT1DATA_HIGH;
   \   00002C   D296         SETB    0x90.6
    345            SHT1_SendAck();
   \   00002E                ; Setup parameters for call to function SHT1_SendAck
   \   00002E   12....       LCALL   ??SHT1_SendAck?relay
    346            
    347            return lResult;
   \   000031   E4           CLR     A
   \   000032   F5..         MOV     ?V0 + 5,A
   \   000034   F5..         MOV     ?V0 + 6,A
   \   000036   F5..         MOV     ?V0 + 7,A
   \   000038   7410         MOV     A,#0x10
   \   00003A   78..         MOV     R0,#?V0 + 4
   \   00003C   12....       LCALL   ?L_SHL
   \   00003F   C5..         XCH     A,?V0 + 0
   \   000041   F5..         MOV     ?V0 + 1,A
   \   000043   E4           CLR     A
   \   000044   F5..         MOV     ?V0 + 2,A
   \   000046   F5..         MOV     ?V0 + 3,A
   \   000048   78..         MOV     R0,#?V0 + 4
   \   00004A   79..         MOV     R1,#?V0 + 0
   \   00004C   12....       LCALL   ?L_IOR
   \   00004F   8F..         MOV     ?V0 + 0,R7
   \   000051   E4           CLR     A
   \   000052   F5..         MOV     ?V0 + 1,A
   \   000054   78..         MOV     R0,#?V0 + 4
   \   000056   79..         MOV     R1,#?V0 + 0
   \   000058   12....       LCALL   ?L_IOR
   \   00005B   AA..         MOV     R2,?V0 + 4
   \   00005D   AB..         MOV     R3,?V0 + 5
   \   00005F   AC..         MOV     R4,?V0 + 6
   \   000061   7D00         MOV     R5,#0x0
   \   000063   7F08         MOV     R7,#0x8
   \   000065   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000068                REQUIRE _A_P1
    348          }
    349          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    350          uint8 CRC8(uint8 crc, uint8 data)
   \                     CRC8:
    351          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    352            uint8 i;
    353            crc = crc ^data;
   \   000000   EA           MOV     A,R2
   \   000001   C9           XCH     A,R1
   \   000002   69           XRL     A,R1
   \   000003   F9           MOV     R1,A
    354            for (i = 0; i < 8; i++)
   \   000004   7808         MOV     R0,#0x8
    355            {
    356               if ((crc & 0x01) != 0) crc = (crc >> 1) ^ 0x8c;
   \                     ??CRC8_0:
   \   000006   E9           MOV     A,R1
   \   000007   A2E0         MOV     C,0xE0 /* A   */.0
   \   000009   5006         JNC     ??CRC8_1
   \   00000B   C3           CLR     C
   \   00000C   13           RRC     A
   \   00000D   648C         XRL     A,#0x8c
   \   00000F   8002         SJMP    ??CRC8_2
    357               else crc = crc >> 1;
   \                     ??CRC8_1:
   \   000011   C3           CLR     C
   \   000012   13           RRC     A
   \                     ??CRC8_2:
   \   000013   F9           MOV     R1,A
    358            }
   \   000014   18           DEC     R0
   \   000015   E8           MOV     A,R0
   \   000016   70EE         JNZ     ??CRC8_0
    359            return crc;
   \   000018   02....       LJMP    ?BRET
    360          }

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??SET_ADC_IO_SLEEP_MODE?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    SET_ADC_IO_SLEEP_MODE

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ReadAdcValue?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ReadAdcValue

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??Sensor_PIN_INT?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    Sensor_PIN_INT

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??SHT1_Reset?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    SHT1_Reset

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??SHT1_Start?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    SHT1_Start

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??SHT1_Ready?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    SHT1_Ready

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??SHT1_SendAck?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    SHT1_SendAck

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??SHT1_WriteCommandData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    SHT1_WriteCommandData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??SHT1_ReadData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    SHT1_ReadData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??SHT1_WriteReg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    SHT1_WriteReg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??SHT1_ReadReg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    SHT1_ReadReg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ReadSHT1?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ReadSHT1

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??CRC8?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    CRC8
    361          /*
    362          unsigned CHAR code CCITT_CRC8[256] = 
    363          {
    364              0x00, 0x5e, 0xbc, 0xe2, 0x61, 0x3f, 0xdd, 0x83,
    365              0xc2, 0x9c, 0x7e, 0x20, 0xa3, 0xfd, 0x1f, 0x41,
    366              0x9d, 0xc3, 0x21, 0x7f, 0xfc, 0xa2, 0x40, 0x1e,
    367              0x5f, 0x01, 0xe3, 0xbd, 0x3e, 0x60, 0x82, 0xdc,
    368              0x23, 0x7d, 0x9f, 0xc1, 0x42, 0x1c, 0xfe, 0xa0,
    369              0xe1, 0xbf, 0x5d, 0x03, 0x80, 0xde, 0x3c, 0x62,
    370              0xbe, 0xe0, 0x02, 0x5c, 0xdf, 0x81, 0x63, 0x3d,
    371              0x7c, 0x22, 0xc0, 0x9e, 0x1d, 0x43, 0xa1, 0xff,
    372              0x46, 0x18, 0xfa, 0xa4, 0x27, 0x79, 0x9b, 0xc5,
    373              0x84, 0xda, 0x38, 0x66, 0xe5, 0xbb, 0x59, 0x07,
    374              0xdb, 0x85, 0x67, 0x39, 0xba, 0xe4, 0x06, 0x58,
    375              0x19, 0x47, 0xa5, 0xfb, 0x78, 0x26, 0xc4, 0x9a,
    376              0x65, 0x3b, 0xd9, 0x87, 0x04, 0x5a, 0xb8, 0xe6,
    377              0xa7, 0xf9, 0x1b, 0x45, 0xc6, 0x98, 0x7a, 0x24,
    378              0xf8, 0xa6, 0x44, 0x1a, 0x99, 0xc7, 0x25, 0x7b,
    379              0x3a, 0x64, 0x86, 0xd8, 0x5b, 0x05, 0xe7, 0xb9,
    380              0x8c, 0xd2, 0x30, 0x6e, 0xed, 0xb3, 0x51, 0x0f,
    381              0x4e, 0x10, 0xf2, 0xac, 0x2f, 0x71, 0x93, 0xcd,
    382              0x11, 0x4f, 0xad, 0xf3, 0x70, 0x2e, 0xcc, 0x92,
    383              0xd3, 0x8d, 0x6f, 0x31, 0xb2, 0xec, 0x0e, 0x50,
    384              0xaf, 0xf1, 0x13, 0x4d, 0xce, 0x90, 0x72, 0x2c,
    385              0x6d, 0x33, 0xd1, 0x8f, 0x0c, 0x52, 0xb0, 0xee,
    386              0x32, 0x6c, 0x8e, 0xd0, 0x53, 0x0d, 0xef, 0xb1,
    387              0xf0, 0xae, 0x4c, 0x12, 0x91, 0xcf, 0x2d, 0x73,
    388              0xca, 0x94, 0x76, 0x28, 0xab, 0xf5, 0x17, 0x49,
    389              0x08, 0x56, 0xb4, 0xea, 0x69, 0x37, 0xd5, 0x8b,
    390              0x57, 0x09, 0xeb, 0xb5, 0x36, 0x68, 0x8a, 0xd4,
    391              0x95, 0xcb, 0x29, 0x77, 0xf4, 0xaa, 0x48, 0x16,
    392              0xe9, 0xb7, 0x55, 0x0b, 0x88, 0xd6, 0x34, 0x6a,
    393              0x2b, 0x75, 0x97, 0xc9, 0x4a, 0x14, 0xf6, 0xa8,
    394              0x74, 0x2a, 0xc8, 0x96, 0x15, 0x4b, 0xa9, 0xf7,
    395              0xb6, 0xe8, 0x0a, 0x54, 0xd7, 0x89, 0x6b, 0x35
    396          };
    397          */
    398          /*interrupt
    399          OFFSET   EQU    0x800
    400          
    401                          COMMON  INTVEC(1)
    402                          ;
    403                          ; the interrupt vectors in the boot code simply jump to the user's LJMP
    404                          ; instruction based at the known offset of 0x800 (flash page 1).
    405                          ;
    406                          ; the boot code does not use interrupts.
    407          
    408             ORG     0x0003      ; RF Tx FIFO underflow and overflow
    409             LJMP  $ + OFFSET
    410             ORG     0x000B      ; ADC end of conversion
    411             LJMP  $ + OFFSET
    412             ORG     0x0013      ; USART0 Rx complete
    413             LJMP  $ + OFFSET
    414             ORG     0x001B      ; USART1 Rx complete
    415             LJMP  $ + OFFSET
    416             ORG     0x0023      ; AES encryption/decryption complete
    417             LJMP  $ + OFFSET
    418             ORG     0x002B      ; Sleep timer compare
    419             LJMP  $ + OFFSET
    420             ORG     0x0033      ; Port 2 inputs
    421             LJMP  $ + OFFSET
    422             ORG     0x003B      ; USART0 Tx complete
    423             LJMP  $ + OFFSET
    424             ORG     0x0043      ; DMA transfer complete
    425             LJMP  $ + OFFSET
    426             ORG     0x004B      ; Timer 1 (16-bit) capture/compare/overflow
    427             LJMP  $ + OFFSET
    428             ORG     0x0053      ; Timer 2 (MAC timer)
    429             LJMP  $ + OFFSET
    430             ORG     0x005B      ; Timer 3 (8-bit) capture/compare/overflow
    431             LJMP  $ + OFFSET
    432             ORG     0x0063      ; Timer 4 (8-bit) capture/compare/overflow
    433             LJMP  $ + OFFSET
    434             ORG     0x006B      ; Port 0 inputs
    435             LJMP  $ + OFFSET
    436             ORG     0x0073      ; USART1 Tx complete
    437             LJMP  $ + OFFSET
    438             ORG     0x007B      ; Port 1 inputs
    439             LJMP  $ + OFFSET
    440             ORG     0x0083      ; RF general interrupts
    441             LJMP  $ + OFFSET
    442             ORG     0x008B      ; Watchdog overflow in timer mode
    443             LJMP  $ + OFFSET
    444          */

   Maximum stack usage in bytes:

     Function                   ISTACK PSTACK XSTACK
     --------                   ------ ------ ------
     CRC8                           0      0      0
     ReadAdcValue                   0      0     10
     ReadSHT1                       0      0     16
       -> SHT1_Reset                0      0     32
       -> SHT1_Start                0      0     32
       -> SHT1_WriteCommandData     0      0     32
       -> SHT1_Ready                0      0     32
       -> SHT1_SendAck              0      0     32
       -> SHT1_Ready                0      0     32
       -> SHT1_ReadData             0      0     32
       -> SHT1_SendAck              0      0     32
       -> SHT1_ReadData             0      0     32
       -> SHT1_SendAck              0      0     32
       -> SHT1_ReadData             0      0     32
       -> SHT1_SendAck              0      0     32
     SET_ADC_IO_SLEEP_MODE          0      0      0
     SHT1_ReadData                  0      0     28
       -> SHT1_Ready                0      0     24
     SHT1_ReadReg                   0      0     10
       -> SHT1_Reset                0      0     20
       -> SHT1_Start                0      0     20
       -> SHT1_WriteCommandData     0      0     20
       -> SHT1_Ready                0      0     20
       -> SHT1_SendAck              0      0     20
       -> SHT1_ReadData             0      0     20
       -> SHT1_SendAck              0      0     20
       -> SHT1_ReadData             0      0     20
       -> SHT1_SendAck              0      0     20
     SHT1_Ready                     0      0     16
     SHT1_Reset                     0      0     16
     SHT1_SendAck                   0      0     16
     SHT1_Start                     0      0     16
     SHT1_WriteCommandData          2      0     16
     SHT1_WriteReg                  0      0      9
       -> SHT1_Reset                0      0     18
       -> SHT1_Start                0      0     18
       -> SHT1_WriteCommandData     0      0     18
       -> SHT1_Ready                0      0     18
       -> SHT1_SendAck              0      0     18
       -> SHT1_WriteCommandData     0      0     18
       -> SHT1_Ready                0      0     18
       -> SHT1_SendAck              0      0     18
     Sensor_PIN_INT                 0      0      0


   Segment part sizes:

     Function/Label                Bytes
     --------------                -----
     _A_P0                            1
     PICTL                            1
     P1IEN                            1
     P0INP                            1
     _A_P1                            1
     IEN2                             1
     ADCCON1                          1
     ADCCON3                          1
     ADCL                             1
     ADCH                             1
     APCFG                            1
     P0SEL                            1
     P1SEL                            1
     P1INP                            1
     P2INP                            1
     P0DIR                            1
     P1DIR                            1
     SET_ADC_IO_SLEEP_MODE           50
     ReadAdcValue                    96
     ?Subroutine0                     6
     Sensor_PIN_INT                 216
     SHT1_Reset                      14
     SHT1_Start                      15
     SHT1_Ready                      10
     SHT1_SendAck                     7
     SHT1_WriteCommandData           52
     SHT1_ReadData                   55
     SHT1_WriteReg                   38
     ?Subroutine1                     2
     ??Subroutine4_0                  8
     SHT1_ReadReg                    38
     ?Subroutine3                     2
     ??Subroutine5_0                  8
     ?Subroutine2                     6
     ReadSHT1                       104
     CRC8                            27
     ??SET_ADC_IO_SLEEP_MODE?relay    6
     ??ReadAdcValue?relay             6
     ??Sensor_PIN_INT?relay           6
     ??SHT1_Reset?relay               6
     ??SHT1_Start?relay               6
     ??SHT1_Ready?relay               6
     ??SHT1_SendAck?relay             6
     ??SHT1_WriteCommandData?relay    6
     ??SHT1_ReadData?relay            6
     ??SHT1_WriteReg?relay            6
     ??SHT1_ReadReg?relay             6
     ??ReadSHT1?relay                 6
     ??CRC8?relay                     6

 
 754 bytes in segment BANKED_CODE
  78 bytes in segment BANK_RELAYS
  17 bytes in segment SFR_AN
 
 832 bytes of CODE memory
   0 bytes of DATA memory (+ 17 bytes shared)

Errors: none
Warnings: none
